## 2026-01-06
2つのプロジェクトを作成する

```bash
quarkus create app inuverse:consumer-a \
    --extension='kotlin' \
    --gradle-kotlin-dsl
```

```bash
quarkus create app inuverse:consumer-b \
    --extension='kotlin' \
    --gradle-kotlin-dsl
```

ちな、dslはdomain specific languageの略な

REST-APIに対応させたい。エントリーポイントがないので[JSON RESTサービスを実装](https://ja.quarkus.io/guides/rest-json)を参考にする

`Quarkus.run(*args)`が呼び出されると、Quarkusのブートストラッププロセスが開始する。
Quarkusの起動シーケンスは、
1. クラスパススキャン
2. CDI（Contexts and Dependency Injection）コンテナが構築
3. @ApplicationScoped、@Singleton、@Inject などのアノテーションが付いたクラスがインスタンス化 
4. 拡張機能（extensions）の初期化
5. Quarkus が組み込まれている拡張（例: quarkus-resteasy, quarkus-smallrye-reactive-messaging など）が起動 
6. @Observes StartupEvent がトリガー

Xxx.onStart が最初に呼び出されます（`StartupEvent`を受け取るメソッドはQuarkusが起動完了直後に実行）。

例えば下記のイメージ
```kotlin
@Inject
lateinit var config: XxxConfig
fun onStart(@Observes startupEvent: StartupEvent) {
    println("StartEvent")
}
```
StartupEvent, ShutdownEventを学ぶ
[アプリケーションの初期化と終了](https://ja.quarkus.io/guides/lifecycle)

## 2026-01-07
- RabbitMQを追加
- docker-compose.yamlを追加
- `docker-compose up --build -d`


1. ディレクトリ構造とDocker設定の不一致
* 問題: docker-compose.yamlがサンプルのままで、現在のプロジェクト（consumer-a, consumer-b）のパスや構成を認識できていない
* 解決: docker-compose.yamlを書き換え、現在のフォルダ構成とサービス名に合わせてビルド・起動できるように修正

2. RabbitMQの受信設定の不足
* 問題: consumer-aのプログラムコード（QuoteResource.kt）では処理結果を受信しようとしていたが、application.propertiesに「どのQueueから受信す
  るか」という定義が欠落
* 解決: consumer-aに受信チャネル（mp.messaging.incoming.quotes）の設定を追加

3. コンテナ間のネットワーク接続エラー（Connection Refused）
* 問題: アプリケーションがRabbitMQの接続先をデフォルトのlocalhostと誤認しており、コンテナ外のRabbitMQサービス（rabbit
  ホスト）を見つけられず、接続拒否が発生
* 解決:
    * application.propertiesで環境変数を介して接続先ホスト（rabbitmq-host）を動的に設定できるように修正。
    * docker-compose.yamlで環境変数RABBITMQ_HOST: rabbitを注入し、コンテナ間通信を確立させました。

4. ビルド・デプロイ環境の不整合
* 問題: 初期のビルドで
  Testcontainers（Dockerを用いたテスト）が動作せず、不整合なテストコードによってビルドが失敗
  止していました。
* 解決:
    * 現在は疎通確認を優先するため、不整合なテストをスキップ（-x test）してビルドを成功


```bash
docker-compose down
```

異なるポートでアプリを立ち上げる
consumer-a
```bash
./gradlew quarkusDev
```

consumer-b
```bash
 ./gradlew quarkusDev -Dquarkus.http.port=8081
```
```bash
docker-compose up -d rabbit
```

## 2025-01-08

Kotlinで `private val quotes: Multi<Quote>` とコンストラクタに書くと、コンパイラは内部的に以下の3つを生成する
1. コンストラクタの引数 (parameter)
2. クラスのフィールド (field)
3. 値を返すゲッター (getter)

よって`@Channel`というアノテーションがいまはデフォルトで1だけについているが、将来は2にも自動でつくようになる曖昧さがあるので
警告を出している。

解決策：`@param`をつける
するとコンストラクタは

```kotlin
@param:Channel("quote-requests")
private val quoteRequestEmitter: Emitter<String>
```

のようになる。

---

GCSの`Object Finalize`トリガーを再現するためには、MinIOのBucket Notificationを利用する。
ただし設定が必要で、起動時に環境変数で通知先NATSサーバを指定する
e.g., `MINIO_NOTIFY_NATS_ENABLE_PRIMARY="on"`, `MINIO_NOTIFY_NATS_ADRESS_PRIMARY="nats:4222"`
MinIOのバケットにファイルが置かれると、MinIOが内部に設定されたNATSのSubject（トピック）に対してJSON形式の
イベントデータをPublishする。これがCloud Pub/Subのへのメッセージ発行に対応する。
注意：MinIOコンテナを立ち上げただけでは通知は飛ばない。`mc`　（MinIO Client) コマンドを使用して、
「どのバケット」「どのイベント（put, delete等）を通知するか設定す初期化処理がいる

Cloud Pub/Subのat-least-once, Pull, AckをさいげんするにはNATS JetStreamを使用する
Stream(Topic担当)：MinIOから飛んでくるイベントを永続化
Consumer(Subscription担当)：
- ここでのconsumerはアプリではなく、NATS上の設定オブジェクト
- consumer-aがイベントを受け取ってackを返すまでの制限時間
- MaxDeliverは再送回数

いまはREST APIベース。これをEvent-drivenにしないといけない。
`NATS Trigger` --> `MinIO Download` --> `Split/Chunking` --> `RabbitMQ Enqueu`
- Quarkusでは`quarkus-smallrye-reactive-messaging-nats`を使用
- manual ack

NATS JetStreamの参考
https://gist.github.com/wallyqs/5378f5abcbe4b1b683268cacf2b672d3
https://docs.nats.io/running-a-nats-service/nats_docker

MinIOのDocker-composeの参考
https://github.com/minio/minio/blob/master/docs/orchestration/docker-compose/docker-compose.yaml

--- 


「NATS専用のツール（nats-box）」を使って、minio_events
という名前のトピックに届くメッセージをリアルタイムで表示
```bash
docker run --network rabbitmq-network -it --rm natsio/nats-box nats sub -s nats:4222 minio_events
```

http://localhost:9001
でminioの管理画面を開く

得られる結果はこれ
```json
{"EventName":"s3:ObjectCreated:Put","Key":"stock-data/init_stock0012_20251016063033.gz","Records":[{"eventVersion":"2.0","eventSource":"minio:s3","awsRegion":"","eventTime":"2026-01-08T05:26:58.193Z","eventName":"s3:ObjectCreated:Put","userIdentity":{"principalId":"minioadmin"},"requestParameters":{"principalId":"minioadmin","region":"","sourceIPAddress":"192.168.155.1"},"responseElements":{"x-amz-id-2":"dd9025bab4ad464b049177c95eb6ebf374d3b3fd1af9251148b658df7ac2e3e8","x-amz-request-id":"1888AA399CD6A201","x-minio-deployment-id":"c03266b5-3d99-4b8f-aa92-821ecfcbc7ef","x-minio-origin-endpoint":"http://192.168.155.4:9000"},"s3":{"s3SchemaVersion":"1.0","configurationId":"Config","bucket":{"name":"stock-data","ownerIdentity":{"principalId":"minioadmin"},"arn":"arn:aws:s3:::stock-data"},"object":{"key":"init_stock0012_20251016063033.gz","size":542107,"eTag":"6ad8be3576bc9ee58896415d5338258b","contentType":"application/x-gzip","userMetadata":{"content-type":"application/x-gzip"},"sequencer":"1888AA399E3A0030"}},"source":{"host":"192.168.155.1","port":"","userAgent":"MinIO (linux; arm64) minio-go/v7.0.91 MinIO Console/(dev)"}}]}
```

localhostでconsumer-aを起動するとき
```bash
RABBITMQ_HOST=localhost \
  NATS_HOST=localhost \
  MINIO_URL=http://localhost:9000 \
  ./gradlew quarkusDev
```

https://docs.quarkiverse.io/quarkus-reactive-messaging-nats-jetstream/dev/index.html
これが参考になる。特に
```bash
# Inbound
mp.messaging.incoming.[channel-name].connector=quarkus-jetstream
```
は俺の勝ち